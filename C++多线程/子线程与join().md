## 为什么等待线程执行要叫做join？

### “汇合” 的比喻

想象一下两个并行前进的路径：

- 一条路径是**主线程**（或调用 `join` 的线程）。
- 另一条路径是**子线程**（被 `join` 的线程）。

当主线程调用 `子线程.join()` 时，它的含义是：

> “我（主线程）要在这里停下来，**等待**你（子线程）完成你自己的任务。直到你跑完，我们两个的执行路径才能**汇合**（join）在一起，然后我才能继续往下走。”

这就像两条分叉的河流，最终在某个点汇合到一起。`join` 操作就是那个“汇合点”。

### 对比 `detach`

C++ 线程还有另一个操作叫 `detach()`。`detach` 的意思是“分离”，即主线程和子线程**分离**，不再有联系，子线程变成“后台线程”独立运行，主线程不会等待它。

`join` 和 `detach` 是一对**对立**的操作：

- `join`：**汇合**，等待并同步。
- `detach`：**分离**，不等待，异步。

## 在main中创建子线程t1后，主线程和子线程分别是？

**执行 `t1.join()` 的线程是“等待者”（可以理解为逻辑上的“主线程”），而 `t1` 代表的线程是“被等待者”（子线程）**。

- **`t1`**: 这是一个 `std::thread` 对象，它**代表**一个正在（或即将）独立执行的线程。这个线程通常被称为**子线程**。
- **`t1.join()`**: 这是一个成员函数调用。**调用这个函数的线程**会在此处阻塞（暂停执行），直到 `t1` 所代表的线程完全执行完毕。

## 创建线程时任务就开始执行？

当创建一个 `std::thread` 对象并传入一个可调用对象（如函数）时，新线程的执行**通常会立即开始**。

### 如果不 `join`，直接使用线程的结果，是否会崩溃？

不一定立即“崩溃”（如段错误），但极大概率会导致“未定义行为”或逻辑错误，结果是不可预测和错误的。