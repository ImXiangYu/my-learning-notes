# C++11下的多线程安全

## 多线程安全的本质

- 所有线程的操作，都可以被其他线程“穿插”
- 即使被穿插了，程序的运行结果也总是相同
- 这就是多线程安全的程序

## 大前提

只读变量永远不会有多线程冲突，无论先读还是后读都不影响结果，但写入不一样，写操作违背了多线程安全

## 写独占定律

1. 一个线程自己独占的变量是安全的
2. 多个线程共享同一个变量，但是他们都只是读取，也是安全的

## lock_guard

假如在unlock之前抛出了异常且被接收，则锁不会被释放，此时可以用lock_guard来代替catch中unlock

例如：使用lock_guard之前

```cpp
void t1() {
	try {
        mutex_a.lock();
        a = "123";
        throw std::runtime_error("出了问题");
        mutex_a.unlock();
    } catch(...) {
        mutex_a.unlock();
    }
}
```

可以使用lock_guard代替这种操作

```cpp
void t1() {
	try {
        std::lock_guard<std::mutex> lock(mutex_a);
        a = "123";
        throw std::runtime_error("出了问题");
    } catch(...) {
        mutex_a.unlock();
    }
}
```

std::lock_guard 是一个 RAII 风格的锁管理器，用于自动管理锁的生命周期。

std::lock_guard利用了C++析构函数的特性，如果只想锁一部分，可以用花括号括起来

```cpp
void t1() {
	int b;
	{
		std::lock_guard<std::mutex> lock(mutex_a);
	}
	b = 2;
}
```

那如果想提前退出呢？可以使用unique_lock

## unique_lock

std::unique_lock 提供了比 std::lock_guard 更灵活的锁管理。

```
void t1() {
	std::unique_guard<std::mutex> lock(mutex_a);
	a = "123";
	lock.unlock();
}
```

## condition_variable

wait()和notify_one();

wait()一定记着和while一起用，如果已经通知过了就不用wait了，否则如果先发通知后wait，就会卡住

## 不要带着锁睡觉

不要带着锁睡觉

## mutex和cv

只有mutex，mutex避免了穿插，但并不保证顺序

mutex+cv，mutex避免穿插，cv保证顺序
